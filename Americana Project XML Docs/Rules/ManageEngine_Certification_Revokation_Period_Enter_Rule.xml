<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE sailpoint PUBLIC "sailpoint.dtd" "sailpoint.dtd">
<sailpoint>
<Rule language="beanshell" name="ManageEngine_Certification_Revokation_Period_Enter_Rule" type="CertificationPhaseChange">
  <Description>This rule is run when the certification either enters or leaves a phase.</Description>
  <Signature returnType="void">
    <Inputs>
      <Argument name="log" type="org.apache.commons.logging.Log">
        <Description>
          The log object associated with the SailPointContext.
        </Description>
      </Argument>
      <Argument name="context" type="sailpoint.api.SailPointContext">
        <Description>
          A sailpoint.api.SailPointContext object that can be used to query the database if necessary.
        </Description>
      </Argument>
      <Argument name="certification">
        <Description>
          The sailpoint.object.Certification being certified.
        </Description>
      </Argument>
      <Argument name="certificationItem">
        <Description>
          The sailpoint.object.CertificationItem that is being certified.
        </Description>
      </Argument>
      <Argument name="previousPhase">
        <Description>
          Certification.Phase (may be null) that is the previous phase.
        </Description>
      </Argument>
      <Argument name="nextPhase">
        <Description>
          Certification.Phase (may be null) that is the next phase.
        </Description>
      </Argument>
    </Inputs>
  </Signature>
  <Source>
  import sailpoint.tools.Util;
  import sailpoint.object.Application;
  import sailpoint.object.EmailTemplate;
  import sailpoint.object.EmailOptions;
  import sailpoint.object.CertificationEntity;
  import sailpoint.object.CertificationItem;
  import sailpoint.object.Certification;
   import sailpoint.object.Identity;
  import sailpoint.object.CertificationAction;

  {
    public void sendNotificationForNonProvisionApplications(CertificationItem certificationItem, String emailTempName, Identity identityObject, String status)
    {
      
      Map nonProvisionAppsWithNotifiers = new HashMap();

      if (certificationItem != null)
      {
        Set applications = certificationItem.getApplications(context);
        if (applications != null)
        {
          for (Application app : applications)
          {
            if (app != null &amp;&amp; app.getFeaturesString() != null &amp;&amp; !Util.csvToList(app.getFeaturesString()).contains("PROVISIONING") 
                &amp;&amp; null != app.getName() &amp;&amp; app.getName().equals("ManageEngine"))
            {

              nonProvisionAppsWithNotifiers.put(app.getName(),"servicedesk@americana-food.com");
              
            }
          }
        }
      }
      for (Map.Entry entry : nonProvisionAppsWithNotifiers.entrySet())
      {
        String notifier = entry.getValue();
        if (Util.isNotNullOrEmpty(notifier))
        {
        
        EmailTemplate emailTemplate = context.getObjectByName(EmailTemplate.class, emailTempName);
          
    String  displayName=(String)  identityObject.getAttribute("displayName");
    String  employeeNumber=(String) identityObject.getAttribute("employeeNumber");
    String  PositionName=(String) identityObject.getAttribute("PositionName");
    String  department=(String) identityObject.getAttribute("department");
    String  startDate=(String) identityObject.getAttribute("startDate");
    String  endDate=(String) identityObject.getAttribute("endDate");
	  String  mail=(String) identityObject.getEmail();

    String  manager;
    if(identityObject.getManager() != null &amp;&amp; identityObject.getManager().getDisplayName() != null){
      manager=(String) identityObject.getManager().getDisplayName();
    }

    EmailOptions emailOptions = new EmailOptions();

    Map args = new HashMap();
    args.put("identityName",displayName);
    args.put("item",status);
    args.put("displayName",displayName);
    args.put("employeeNumber",employeeNumber);
    args.put("PositionName",PositionName);
    args.put("department",department);
    args.put("startDate",startDate);
    args.put("endDate",endDate);
    args.put("email",mail);
    args.put("manager",manager);

    emailOptions.setVariables(args);
    emailOptions.setTo(notifier);

    context.sendEmailNotification(emailTemplate,emailOptions);
      
        }
      }
      
    }
    try {
      
      Identity identity = null;
      
      if (certification != null)
      {
        List entities = certification.getEntities();
        if (Util.nullSafeSize(entities) &gt; 0)
        {
          for (CertificationEntity entity : entities)
          {
         String identityName =  entity.getIdentity();
          identity =  context.getObjectByName(Identity.class,identityName);
            
            if (entity != null)
            {
              List items = entity.getItems();
              if (Util.nullSafeSize(items) &gt; 0)
              {
                for (CertificationItem certificationItem : items)
                {
                  if (certificationItem != null)
                  {
                    CertificationAction action = certificationItem.getAction();
                    if (action != null &amp;&amp; action.getStatus() != null &amp;&amp; action.getStatus().equals(CertificationAction.Status.Remediated))
                    {
                      sendNotificationForNonProvisionApplications(certificationItem, "EmailTemplate-Accees Review Revocation", identity, "Access Deprovisioning");

                    }
                  }
                }
              }
            }
          }
        }
      }
      
    } 
    catch (Exception e)
    {
      System.out.println(e);
    }
  }
  </Source>
</Rule>

</sailpoint>